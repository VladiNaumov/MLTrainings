#!/usr/bin/env python
# coding: utf-8

# In[ ]:


import numpy as np
import random
import scipy.stats as sps


# ### Задание 1
# В первой задаче вам предлагается перемножить две квадратные матрицы двумя способами -- без использования пакета ***numpy*** и с ним.

# In[ ]:


# Для генерации матриц используем фукнцию random -- она используется для генерации случайных объектов 
# функция sample создает случайную выборку. В качестве аргумента ей передается кортеж (i,j),  
# здесь i -- число строк, j -- число столбцов.
a = np.random.sample((100, 100))
b = np.random.sample((100, 100))

# Выведите размерность (ранг) каждой матрицы с помощью функции ndim.
# Используйте функцию shape, что она вывела?

# ========
# Ваш код здесь
# ========
print(a)
print(b)


# In[ ]:


def mult(a, b):
    """  
    a: list of "size" lists, each contains "size" floats --- первая матрица-аргумент
    b: list of "size" lists, each contains "size" floats --- вторая матрица-аргумент
    return c: list of "size" lists, each contains "size" floats --- матрица, являющаяся результатом умножения матриц a и b
    
    Функция принимает на вход две матрицы: a и b размерностью size x size
    Возвращает матрицу их произведения a * b = c 

    Реализуйте умножение матриц без использования функций из пакета numpy
    """
    pass


# In[ ]:


def np_mult(a, b):
    """  
    a: np.array[size, size]             --- первая матрица-аргумент
    b: np.array[size, size] --- вторая матрица-аргумент
    return c: np.array[size, size]       --- матрица, являющаяся результатом умножения матриц a и b
    
    Функция принимает на вход две матрицы: a и b размерностью size x size
    Возвращает матрицу их произведения a * b = c 

    Реализуйте умножение матриц, используя функции из пакета numpy
    """
    pass


# In[ ]:


get_ipython().run_cell_magic('time', '', '# засечем время работы функции без NumPy\nM1 = mult(a, b)')


# In[ ]:


get_ipython().run_cell_magic('time', '', '# засечем время работы функции с NumPy\nM2 = np_mult(a, b)')


# In[ ]:


# проверим корректность
assert np.allclose(np.array(M1), M2)


# ### Задание 2

# Вам подаются на вход два вектора `a` и `b` в трехмерном пространстве. Заполните их случайными числами. Реализуйте их скалярное произведение с помощью  `NumPy` и без. Засеките время работы, как это показано в заданиях выше.

# In[ ]:


a = np.random.sample((1, 3))
a = list(a)[0]
b = np.random.sample((1, 3))
b = list(b)[0]
print(a, b)


# In[ ]:


def scalar_product(a, b):
    """  
    a: np.array[, n] --- первая матрица-аргумент длиной n
    b: np.array[, n] --- вторая матрица-аргумент длиной n
    return c: float  --- результат скалярного произведения векторов a и b

    Функция принимает на вход два вектора длиной n
    Возвращает число, равное их скалярному произведению a x b = c 

    Реализуйте скалярное умножение векторов, не используя функции из пакета numpy

    """ 
    pass


# In[ ]:


def np_scalar_product(a,b):
    """  
    a: np.array[, n] --- первая матрица-аргумент
    b: np.array[, n] --- вторая матрица-аргумент
    return c: float  --- результат скалярного произведения векторов a и b

    Функция принимает на вход два вектора длиной n
    Возвращает число, равное их скалярному произведению a x b = c 

    Реализуйте скалярное умножение векторов, используя функции из пакета numpy
    """ 
    pass


# In[ ]:


get_ipython().run_line_magic('time', 'product_1 = scalar_product(a,b)')
get_ipython().run_line_magic('time', 'product_2 = np_scalar_product(a,b)')

# проверим корректность:
assert np.allclose(product_1, product_2)


# Почему методы ***numpy*** оказываются эффективнее? Что вы можете сказать о скорости вычислений в NumPy?

# ------------------

# **Ответ:** Скорость вычислений вектоных и матричных операций в NumPy сильно превосходит скорость вычислений без него, по большей части потому, что функции numpy работаю с массивами данных одного типа (числовыми), это позволяет реализовать встроенные функции numpy на C/C++, что, конечно, делает numpy быстрее (функции, которые вызывает Numpy для работы с числовыми данными, сильно оптимизированы именно под эти задачи, а сам Python просто гоняет интерпретатор по циклу в таких операциях, что является чуть ли не самым большим замедлением в работе интерпретатора).

# ### Задание 3
# Напишите функцию, которая находим сумму четных диагональныех элементов квадратной матрицы. Если таких элементов нет, то вывести `0`. Используйте библиотеку Numpy

# In[ ]:


def np_diag_2k(a):
    """  
    a: np.array[m, m] --- первая матрица-аргумент
    return c: float   --- сумма элементов массива а, принадлежащих диагонали и являющимися четными

    Функция принимает на вход квадратную матрицу размерностью m x m и возвращает число,
    равное сумме четных диагональных элементов этой квадратной матрицы

    В реализации этой функции необходимо использовать функционал пакета numpy

    """ 
    pass


# In[ ]:


# зададим некоторую квадратную матрицу
a = np.random.randint(1, 10, size=(5, 5))
a


# In[ ]:


get_ipython().run_cell_magic('time', '', '# засечем время работы функции с NumPy\nnp_diag_2k(a)')


# ### Задание 4
# ​
# На вход дан двумерный массив $X$. Напишите функцию, которая для каждой строчки $(x = (x_1, x_2, \ldots, x_n)$ массива $X$ строит строчку $s = (s_1, s_2, \ldots, s_n)$,  где $s_k=x_1+...+x_k$, а затем выдаёт массив из построенных строчек. Используйте библиотеку <code>numpy</code> (вам поможет функция <code>cumsum</code>). Выходом функции должен быть двумерный <code>numpy</code>-массив той же формы, что и $X$.
# ​ 

# In[ ]:


def cumsum(A):
    """  
    A: np.array[num_row, num_column]        --- матрица-аргумент
    return S: np.array[num_row, num_column] --- выходная матрица кумулятивных сумм

    Функция принимает на вход матрицу A размерностью n x m и возвращает 
    матрицу с той же размерностью n x m, i-ая строчка которой есть последовательность 
    кумулятивных сумм элементов i-ой строки матрицы A

    В реализации этой функции необходимо использовать функционал пакета numpy

    """ 
    pass


# In[ ]:


# зададим некоторую последовательность и проверим ее на вашей функции. 
A = sps.uniform.rvs(size=10**3) 

get_ipython().run_line_magic('time', 'S2 = cumsum(A)')


# ### Задание 5
# 
# ​
# Задан двумерный массив $X$. Для каждой строчки массива X необходимо сделать следующее преобразование.
# 
# Пусть дана строчка x. Необходимо построить новый массив, где все элементы с нечетными индексами требуется заменить на число a (значение по умолчанию a=1). Все элементы с четными индексами нужно возвести в куб. Затем записать элементы в обратном порядке относительно их позиций. В конце требуется слить массив x с преобразованным x и вывести.
# 
# Напишите функцию, которая выполняет данное преобразование для каждой строчки двумерного массива X. Массив X при этом должен остаться без изменений.
# 
# Используйте библиотеку numpy.
# 
# Пример:
# $X = [[100,200,300,400,500]]$ -> $[[100,a,300,a,500]]$ -> $[[500^3,a,300^3,a,100^3]]$ -> склеиваем -> $[[100,200,300,400,500,500^3,a,300^3,a,100^3]]$
# 
# ​

# In[ ]:


from copy import copy
def np_transformation(X, a=1):
    """  
    X: np.array[num_row, num_column]          --- матрица-аргумент
    a: float                                  --- значение для преобразования нечетных элементов строк в X
    return S: np.array[num_row, num_column*2] --- матрица, где строки являются 
    сконкатенированными строками изначальной матрицы X со строками, являющимися их преобразованиями

    Функция принимает на вход матрицу X размерностью n x m, число a и 
    возвращает  матрицу с размерностью n x m*2, i-ая строчка которой является склеенной
    i-ой строкой X с ее преобразованием ее строки transformation(X[i]), записанном в обратном порядке, 
    где преобразование для числа k определено как:
    transformation(k) = a if ind(k) % 2 == 0 else k**3

    В реализации этой функции необходимо использовать функционал пакета numpy

    """ 
    pass


# In[ ]:


X = np.array([[i for i in range(1, 10, 2)]])
get_ipython().run_line_magic('time', 'S2 = np_transformation(X, 5)')


# ### Задание 6
# Написать функцию для кодирование массива (Run-length encoding). Все подряд идущие повторения элементов функция сжимает в один элемент и считает количество повторений этого элемента. Функция возвращает кортеж из двух векторов одинаковой длины. Первый содержит элементы, а второй — сколько раз их нужно повторить. 
# 
# Пример: encode(np.array([1, 2, 2, 3, 3, 1, 1, 5, 5, 2, 3, 3])) = (np.array[1, 2, 3, 1, 5, 2, 3]), np.array[1, 2, 2, 2, 2, 1, 2])

# In[ ]:


def np_encode(a):
    """  
    a: np.array[, n] --- вектор-аргумент длиной n
    return (elems, repetitions): (np.array, np.array) --- выходной кортеж из вектора 
    элементов и вектора их количеств в подряд идущих повторениях

    Функция принимает на вход вектор a длиной n, добавляет в вектор elem сжатые 
    в один элемент подряд идущие повторения элементов входного вектора a, в вектор 
    repetitions добавляет длины последовательностей подряд идущих повторений. 
    Затем функция возвращает кортеж векторов (elems, repetitions).

    В реализации этой функции необходимо использовать функционал пакета numpy

    """ 
    pass


# In[ ]:


X = np.array([1, 2, 2, 3, 3, 1, 1, 5, 5, 2, 3, 3])

get_ipython().run_line_magic('time', 'x, num = np_encode(X)')

